<!DOCTYPE html>
<html lang="en">
<head>
    <title>EonX Docs</title>

    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet">
    <script defer src="https://kit.fontawesome.com/955de18180.js" crossorigin="anonymous"></script>

    <link rel="icon" href="https://39cszd96rb9jntgd3r2cirij-wpengine.netdna-ssl.com/wp-content/uploads/2019/09/eonx-512-70x70.png" sizes="32x32">
    <link rel="icon" href="https://39cszd96rb9jntgd3r2cirij-wpengine.netdna-ssl.com/wp-content/uploads/2019/09/eonx-512.png" sizes="192x192">
    <link rel="apple-touch-icon-precomposed" href="https://39cszd96rb9jntgd3r2cirij-wpengine.netdna-ssl.com/wp-content/uploads/2019/09/eonx-512.png">

                <link id="theme-style" rel="stylesheet" href="/assets/css/theme.css">
    

    <link id="theme-style" rel="stylesheet" href="/assets/css/theme.css">
    <link id="theme-style" rel="stylesheet" href="/assets/css/prism.css">
</head>

    <body class="docs-page">
    <header class="header fixed-top">
        <div class="branding docs-branding">
            <div class="container-fluid position-relative py-2">
                <div class="docs-logo-wrapper">
                    <button id="docs-sidebar-toggler" class="docs-sidebar-toggler docs-sidebar-visible mr-2 d-xl-none"
                            type="button">
                        <span></span>
                        <span></span>
                        <span></span>
                    </button>
                    <div class="site-logo">
                        <a class="navbar-brand" href="/">
                            <img class="logo-icon mr-2"
                                 src="https://39cszd96rb9jntgd3r2cirij-wpengine.netdna-ssl.com/wp-content/uploads/2019/09/eonx-logo@1x.png"
                                 alt="logo">
                        </a>
                    </div>
                </div><!--//docs-logo-wrapper-->
                <div class="docs-top-utilities d-flex justify-content-end align-items-center">
                    <div class="top-search-box d-none d-lg-flex">
                        <form class="search-form">
                            <input type="text" placeholder="Search the docs..." name="search"
                                   class="form-control search-input">
                            <button type="submit" class="btn search-btn" value="Search"><i class="fas fa-search"></i>
                            </button>
                        </form>
                    </div>

                                                                                                                                                            </div><!--//docs-top-utilities-->
            </div><!--//container-->
        </div><!--//branding-->
    </header><!--//header-->

        <div class="docs-wrapper">
        <div id="docs-sidebar" class="docs-sidebar">
            <nav id="docs-nav" class="docs-nav navbar">
                <ul class="section-items list-unstyled nav flex-column pb-3">
                    <li class="nav-item section-title">
                        <a class="nav-link scrollto active" href="#intro">
                        <span class="theme-icon-holder mr-2">
                            <i class="fas fa-cubes"></i>
                        </span>
                            eonx-com/search
                        </a>
                    </li>

                                            <li class="nav-item ">
                                                        <a class="nav-link scrollto" href="#eonx-com_search_UPGRADING">
                                UPGRADING.md
                            </a>
                        </li>
                                            <li class="nav-item ">
                                                        <a class="nav-link scrollto" href="#eonx-com_search_readme">
                                readme.md
                            </a>
                        </li>
                                    </ul>
            </nav>
        </div>
        <div class="docs-content">
            <div class="container">
                <article class="docs-article" id="intro">
                    <header class="docs-header">
                        <h1 class="docs-heading">
                            eonx-com/search
                            <a href="https://github.com/eonx-com/search"><i class="fa fa-github"></i></a>
                        </h1>
                        <section class="docs-intro">
                            <p>Search functionality provided by elastic search</p>
                        </section>
                    </header>

                                            <section class="docs-section" id="eonx-com_search_UPGRADING">
                            <h2 class="section-heading">
                                UPGRADING.md
                                <div class="docs-time">
                                    <a href="https://github.com/eonx-com/search/edit/master/UPGRADING.md" target="_blank" title="Edit on Github">
                                        Edit on github <i class="fa fa-github"></i>
                                    </a>
                                </div>
                            </h2>

                            <h1>Upgrading</h1>
<h2>2.0</h2>
<ul>
<li>The <code>EntitySearchHandlerInterface</code> no longer exists, and should be replaced with <code>TransformableSearchHandlerInterface</code></li>
<li>This interface defines an additional method <code>getFillIterable()</code> which should return an iterable of all objects that are intended to fill the search index.
<ul>
<li>For Doctrine entities, defining a method on the entities' repository that will return the iterable that can be used by the search handler:</li>
</ul></li>
</ul>
<pre><code class="language-php">// EntityRepository.php
    public function getFillIterable(): iterable
    {
        $builder = $this-&gt;createQueryBuilder('e');
        foreach ($builder-&gt;getQuery()-&gt;iterate() as $result) {
            yield $result[0];
        }
    }

// AbstractSearchHandler.php
    public function getFillIterable(): iterable
    {
        $repository = $this-&gt;entityManager-&gt;getRepository($this-&gt;entityClass);
        if ($repository instanceof MultitenancyRepositoryInterface === false) {
            throw new UnsupportedRepositoryException(
                'exceptions.services.search.handlers.unsupported_repository'
            );
        }

        /**
         * @var \App\Database\Repositories\MultitenantRepository $repository
         *
         * @see https://youtrack.jetbrains.com/issue/WI-37859 - typehint required until PhpStorm recognises === check
         */

        return $repository-&gt;getFillIterable();
    }</code></pre>
                        </section>
                                            <section class="docs-section" id="eonx-com_search_readme">
                            <h2 class="section-heading">
                                readme.md
                                <div class="docs-time">
                                    <a href="https://github.com/eonx-com/search/edit/master/readme.md" target="_blank" title="Edit on Github">
                                        Edit on github <i class="fa fa-github"></i>
                                    </a>
                                </div>
                            </h2>

                            <h1>Search</h1>
<p>The goals of this search package are to provide common functionality that enables creating and
maintaining Elasticsearch search indices for an application.</p>
<p>It is up to the application to provide implementations of the <code>SearchHandlerInterface</code> (for simple
search indices that the package will ensure are created) and <code>TransformableSearchHandlerInterface</code>
(for indices that will react to changes to entities in external systems and transform those entities
into search documents to be indexed).</p>
<p>An example implementation of both is provided.</p>
<h2>Overview</h2>
<p>This package provides multiple parts to enable easy search.</p>
<ul>
<li>There are index management commands provided that allow for reindexing without destroying the
previous indices.</li>
<li>Command options that will only reindex when the index mappings have changed
(not yet implemented PYMT-1690)</li>
<li>The Lumen service provider will auto discover any services tagged with <code>search_handler</code> and will
use those discovered handlers to create and manage indices in Elasticsearch.</li>
<li>The Lumen bridge providers a listener that will react to any Doctrine entity changes through the
use of EasyEntityChange.</li>
<li>The search handler interfaces provide multiple options for implementation depending on the
application requirements.</li>
</ul>
<h2>Theory of Operation</h2>
<p>The primary and default implementation of this package sets up a listener that will react to any
entity changes inside Doctrine and dispatch jobs for re-indexing those entities based on Search
Handlers that are interested in specific changes.</p>
<p>Each application Search Handler will define an array of <code>ChangeSubscription</code> DTOs that describe the
entities and relevant properties that should trigger the reindexing of a document.</p>
<p>The package will handle batching search updates into multiple jobs for handling, and pass a
<code>ObjectForChange</code> DTO to the application Search Handler that describes an object that has changed -
either the object was updated or deleted. It is then up to the Search Handler to return a
<code>DocumentAction</code> DTO that describes what should happen to the Elasticsearch document.</p>
<h3>Lifecycle - Index management</h3>
<p>When an application is initially created or deployed, the indices <strong>must</strong> be created before the
application writes to Elasticsearch. Elasticsearch will eagerly create indices which is a behavior
we dont want- so before the application accepts requests a migration/search setup process must run.</p>
<p>Following an imaginary index <code>transactions</code> through the following process:</p>
<pre><code class="language-bash"># This command will create initial indices that are suffixed with the current date, and add an alias
# for each one that is suffixed with _new. No aliases exist at the root at this time.
#
# The system creates a `transactions_20200102121314` and a `transactions_new` alias that points to
# the date suffixed index.
$ ./artisan search:index:create

# This command fills the _new aliases with all document data for any search handlers that implement
# the TransformableSearchHandlerInterface. This command has options for synchronously filling or
# creating jobs to fill with workers.
#
# The system fills all data from the `getFillIterable` method on the TransactionSearchHandler. The
# index is still not live at this point.
$ ./artisan search:index:fill

# This command will atomically swap any root (live) aliases for any indices suffixed with _new that
# have had data populated. After this command is run, the application has been switched to the new
# indexes.
#
# The system sees that `transactions_new` (which points to `transactions_20200102121314`) has data 
# in it, and atomically swaps `transactions` (which currently points to 
# `transactions_20191212121212`) to now point to `transactions_20200102121314`. All index changes 
# occur at the same time and if any fail to swap, they all fail.
$ ./artisan search:index:live

# This command cleans up any old aliases/indices that are no longer required.
#
# The `transactions_2019121212` index is removed.
$ ./artisan search:index:clean</code></pre>
<h3>Lifecycle - reacting to Doctrine changes</h3>
<p>This package listens for <code>EntityChange</code> events from the EasyEntityChange package. The
<code>EntityUpdateWorker</code> converts these events into <code>ObjectForChange</code> DTOs that are then processed
against the Search Handler subscriptions to find any intersections.</p>
<p>Once any intersections are found, the work is batched and dispatched as jobs for workers to process
as required.</p>
<h2>Example Search Handler</h2>
<p>The below example is verbose, and contains code that would normally be placed inside an abstract
search handler, to show the expectations of an implementation of the
<code>TransformableSearchHandlerInterface</code>.</p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace App\Services\Search;

use EonX\EasyEntityChange\DataTransferObjects\ChangedEntity;
use LoyaltyCorp\Search\Bridge\Doctrine\DoctrineSearchHandler;
use LoyaltyCorp\Search\DataTransferObjects\DocumentAction;
use LoyaltyCorp\Search\DataTransferObjects\DocumentDelete;
use LoyaltyCorp\Search\DataTransferObjects\DocumentUpdate;
use LoyaltyCorp\Search\DataTransferObjects\Handlers\ChangeSubscription;
use LoyaltyCorp\Search\DataTransferObjects\Handlers\ObjectForChange;
use LoyaltyCorp\Search\DataTransferObjects\Handlers\ObjectForDelete;
use LoyaltyCorp\Search\DataTransferObjects\Handlers\ObjectForUpdate;

/**
 * This handler represents a single index in Elasticsearch, and reacts to a single primary
 * entity for building those indicies.
 * 
 * The extends annotation below tells phpstan that we're creating a handler for dealing
 * with Transactions only, and enables additional checks to ensure code correctness. For
 * more details, check out PhpStan Generics.
 * 
 * @extends DoctrineSearchHandler&lt;Transaction&gt;
 */
class TransactionHandler extends DoctrineSearchHandler 
{
    /**
     * This method is used to define the Elasticsearch mappings. By convention, our indices should
     * be defined with dynamic-&gt;strict wherever they can be, to avoid issues with mistakes in the
     * transform method or the mappings being out of sync.
     *
     * {@inheritdoc}
     */
    public static function getMappings(): array
    {
        return [
            'doc' =&gt; [
                'dynamic' =&gt; 'strict',
                'properties' =&gt; [
                    'createdAt' =&gt; [
                        'type' =&gt; 'date',
                    ],
                    // Additional mappings as required
                ],
            ],
        ];
    }

    /**
     * Depending on the requirements of the application and if the Elasticsearch system is clustered
     * these settings may need to be modified, but for a default implementation with a single ES node
     * the defaults of 1 for both settings are preferred.
     *
     * {@inheritdoc}
     */
    public static function getSettings(): array
    {
        return [
            'number_of_replicas' =&gt; 1,
            'number_of_shards' =&gt; 1,
        ];
    }

    /**
     * The handler key is used internally by the search package to keep track of which handler needs
     * what data, the key needs to be unique across the application.
     *
     * {@inheritdoc}
     */
    public function getHandlerKey(): string
    {
        return 'transactions';
    }

    /**
     * This is the index name that will be used by the search package. Indexes will be created with
     * a date suffix and aliased to the "real index" name during the search setup or reindexing
     * process.
     *
     * {@inheritdoc}
     */
    public function getIndexName(): string
    {
        return 'transactions';
    }

    /**
     * This method returns the subscriptions for any objects that this search handler is interested
     * in - and optionally a transformation callback that will turn the ChangedEntity that it
     * receives into an iterable of ObjectForUpdate DTOs for batch processing.
     *
     * {@inheritdoc}
     */
    public function getSubscriptions(): iterable
    {
        yield from parent::getSubscriptions();

        // React to transaction metadata changes.
        yield new ChangeSubscription(
            Metadata::class,
            ['key', 'value'],
            fn (ChangedEntity $change) =&gt; $this-&gt;loadTransactionsFromMetadata($change)
        );

        // React to changes to the user's email address
        yield new ChangeSubscription(
            User::class,
            ['email'],
            fn (ChangedEntity $change) =&gt; $this-&gt;loadTransactionsFromUser($change)      
         );
    }

    /**
     * Loads related transactions from a metadata change.
     *
     * @phpstan-return iterable&lt;ObjectForUpdate&lt;Transaction&gt;&gt;
     *
     * @param \EonX\EasyEntityChange\DataTransferObjects\ChangedEntity $change
     *
     * @return \LoyaltyCorp\Search\DataTransferObjects\Handlers\ObjectForChange[]
     */
    public function loadTransactionsFromMetadata(ChangedEntity $change): iterable
    {
        if ($change-&gt;getClass() !== Metadata::class ||
            \is_string($change-&gt;getIds()['metadataId'] ?? null) === false) {
            return [];
        }

        $repository = $this-&gt;getEntityManager()-&gt;getRepository(Transaction::class);

        return $repository-&gt;getSearchTransactionsForMetadataUpdate($change-&gt;getIds()['metadataId']);
    }

    /**
     * Loads related transactions from a user.
     *
     * @phpstan-return iterable&lt;ObjectForUpdate&lt;Transaction&gt;&gt;
     *
     * @param \EonX\EasyEntityChange\DataTransferObjects\ChangedEntity $change
     *
     * @return \LoyaltyCorp\Search\DataTransferObjects\Handlers\ObjectForChange[]
     */
    public function loadTransactionsFromUser(ChangedEntity $change): iterable
    {
        if ($change-&gt;getClass() !== User::class ||
            \is_string($change-&gt;getIds()['userId'] ?? null) === false) {
            return [];
        }

        $repository = $this-&gt;getEntityManager()-&gt;getRepository(Transaction::class);

        return $repository-&gt;getSearchTransactionsForUserUpdate($change-&gt;getIds()['userId']);
    }

    /**
     * This method takes an ObjectForChange and returns a DocumentAction.
     *
     * Its primary purpose is to either decide that a document should be deleted or updated.
     *
     * {@inheritdoc}
     */
    public function transform(ObjectForChange $change): ?DocumentAction
    {
        // We didnt get a $change that makes sense for this transform method.
        if ($change-&gt;getClass() !== Transaction::class ||
            ($change-&gt;getObject() instanceof Transaction) === false) {
            return null;
        }

        // If we got an ObjectForDelete and we have the searchId metadata,
        // issue a delete action to search.
        if ($change instanceof ObjectForDelete === true &amp;&amp;
            \is_string($change-&gt;getMetadata()['searchId'] ?? null) === true) {
            return new DocumentDelete($change-&gt;getMetadata()['searchId']);
        }

        // If we didnt get an Update or Delete we dont know what the system// 
        // wants, lets not do anything.
        if ($change instanceof ObjectForUpdate === false) {
            return null;
        }

        /**
         * PHPStorm isnt capable of recognising that this is a Transaction even though
         * we check it above. This is just for IDE compatibility.
         *
         * @var \App\Database\Entities\Transaction $transaction
         */
        $transaction = $change-&gt;getObject();

        // An object without an external id cannot be transformed.
        if (\is_string($transaction-&gt;getExternalId()) === false) {
            return null;
        }

        return new DocumentUpdate(
            $transaction-&gt;getExternalId(),
            [
                'id' =&gt; $transaction-&gt;getId(),
                'created_at' =&gt; $transaction-&gt;getCreatedAt(),
                // ...
            ]
        );
    }
}</code></pre>
<h3>Example Entity Repository</h3>
<p>Along with the search handler, there are a few methods that need to be implemented into
the entity's repository. The package provides a SearchRepository trait that does the
heavy lifting, but you still need to implement the interface and a few methods that
proxy to the trait.</p>
<pre><code class="language-php">&lt;?php
declare(strict_types=1);

namespace App\Database\Repositories;

use LoyaltyCorp\Search\Bridge\Doctrine\Interfaces\FillableRepositoryInterface;
use LoyaltyCorp\Search\Bridge\Doctrine\SearchRepositoryTrait;
use LoyaltyCorp\Search\DataTransferObjects\Handlers\ObjectForUpdate;

/**
 * @implements FillableRepositoryInterface&lt;Transaction&gt;
 */
class TransactionRepository extends Repository implements FillableRepositoryInterface
{
    use SearchRepositoryTrait;

    /**
     * {@inheritdoc}
     *
     * @throws \Doctrine\ORM\ORMException
     */
    public function getFillIterable(): iterable
    {
        return $this-&gt;doGetFillIterable(
            $this-&gt;createQueryBuilder('e'),
            $this-&gt;entityManager-&gt;getClassMetadata(Transaction::class),
            Transaction::class
        );
    }

    /**
     * Returns an iterable of transactions that relate to a user.
     *
     * @phpstan-return array&lt;ObjectForUpdate&lt;Transaction&gt;&gt;
     *
     * @param string $metadataId
     *
     * @return \LoyaltyCorp\Search\DataTransferObjects\Handlers\ObjectForUpdate[]
     *
     * @throws \Doctrine\ORM\ORMException
     */
    public function getSearchTransactionsForMetadataUpdate(string $metadataId): iterable
    {
        $builder = $this-&gt;createQueryBuilder('t');
        $builder-&gt;select('t.transactionId');

        $builder-&gt;where(':metadata MEMBER OF t.metadata');
        $builder-&gt;setParameter('metadata', $metadataId);

        $index = 0;
        foreach ($builder-&gt;getQuery()-&gt;iterate([], AbstractQuery::HYDRATE_SCALAR) as $result) {
            yield new ObjectForUpdate(
                Transaction::class,
                ['transactionId' =&gt; $result[$index++]['transactionId']]
            );
        }
    }

    /**
     * Returns an iterable of transactions that relate to a user.
     *
     * @phpstan-return array&lt;ObjectForUpdate&lt;Transaction&gt;&gt;
     *
     * @param string $userId
     *
     * @return \LoyaltyCorp\Search\DataTransferObjects\Handlers\ObjectForUpdate[]
     *
     * @throws \Doctrine\ORM\ORMException
     */
    public function getSearchTransactionsForUserUpdate(string $userId): iterable
    {
        $builder = $this-&gt;createQueryBuilder('t');
        $builder-&gt;select('t.transactionId');

        $builder-&gt;where('IDENTITY(t.user) = :user');
        $builder-&gt;setParameter('user', $userId);

        $index = 0;
        foreach ($builder-&gt;getQuery()-&gt;iterate([], AbstractQuery::HYDRATE_SCALAR) as $result) {
            yield new ObjectForUpdate(
                Transaction::class,
                ['transactionId' =&gt; $result[$index++]['transactionId']]
            );
        }
    }

    /**
     * {@inheritdoc}
     *
     * @throws \Doctrine\ORM\Mapping\MappingException
     */
    public function prefillSearch(iterable $changes): void
    {
        $this-&gt;doPrefillSearch(
            $this-&gt;createQueryBuilder('e'),
            $this-&gt;entityManager-&gt;getClassMetadata(Transaction::class),
            Transaction::class,
            $changes
        );
    }
}</code></pre>
                        </section>
                                    </article>
            </div>
        </div>
    </div>
    </body>

        <script src="/assets/js/jquery-3.4.1.min.js"></script>
    <script src="/assets/js/jquery.scrollTo.min.js"></script>
    <script src="/assets/js/popper.min.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>


    <script src="/assets/js/docs.js"></script>

    <script>
        $('pre').addClass('line-numbers');

        $(function (){
            $('.code-toolbar').addClass('shadow-sm');
        });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
    <script src="/assets/js/prism.js"></script>
</html>
